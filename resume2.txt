Fluent with essential programming tools:
* I use Git or another version control system for all of my projects, and can effectively use its features, including branching and merging (https://github.com/lijerom/), also an understanding of semantic versioning
* I have used IDEs including Visual Studio and Eclipse, and configurable editors such as Emacs
* I know how to use command-line toolchains and manually configure project builds (GNU, Stack)
* I can efficiently and effectively use documentation to fill holes in my knowledge when necessary
* Familiar with continuous integration services such as Jenkins (https://ci.lijero.co)
* Efficient reporting and management using bugtrackers such as Mantis and Github Issues
* Microsoft Office, Word, and Excel of course! (in addition to LibreOffice)

Essential systems administration knowledge:
* Windows, Linux (esp. the Debian family) on the desktop and server, FreeBSD (basic familiarity w/ use and its model)
* Nginx (HTTP server & proxy, serves lijero.co), Bind9 (DNS, I run my own authoritative server for lijero.co), Charybdis (IRCd, formerly ran one for my friends), OpenSSHd (for myself, and formerly another two administrators), MySQL/MariaDB (basic familiarity), Murmur (mumble, formerly, for friends), FTP over SSH (I used to use it for file transfers) with my servers and VPSes
* Use an EDCHE-384 manually generated and signed via Let's Encrypt (https://lijero.co), w/ DNS CAA, HSTS (preloaded), OCSP must staple as a certificate extension -- an A+ rating on SSLLabs -- https://www.ssllabs.com/ssltest/analyze.html?d=lijero.co&latest
* Can configure iptables or other firewalls
* Understand how kernels (microkernels and monolithic kernels, exokernels), filesystems, network stacks, memory managers, schedulers, thread priorities, signals, interrupts, system services, kernel modules, program loaders, swap, paging, and other such features work from my own toy operating systems! (though I've only implemented a few of these things-- a basic kernel, file system, and memory manager)
* Basic load balancing techniques, content delivery network use, caches, semantic URLs
* Fundamental knowledge regarding databases: basic SQL, relational algebra, ACID, transactions, CAP theorem, PACELC theorem, CRUD 

Familiarity with essential internet protocols:
* A basic understanding of IP and UDP, and a stronger understanding of TCP
* I understand background behind TLS(/SSL) but not the actual protocol details (I wanted to implement TLS and TCP, but never did)
* I have written HTTP 1.0 client libraries and servers for fun (and I understand how HTTP/2 works, though not enough to implement it)
* HTTP interface design techniques like REST w/ JSON and XML, HTTP functions
* Though it's not a protocol, remote procedure calls as a concept
* An IRC client+bot from scratch capable of all basic functions
* FTP and how it functions, as little as it's used nowadays
and the less essential ones...
* I wrote portions of a Minecraft server a couple years back using reverse-engineered protocol documentation, but not enough to be useful for gameplay (http://wiki.vg/Protocol)
* I wrote internal networking functions for my own Minecraft clone using both TCP and UDP (and that's when I discovered just how unreliable UDP was!)
* Various toy protocols I wrote, eg. a chat protocol

Strong theoretical background:
* Programming language development is my main hobby
* Firm grasp of type theory (polymorphic, dependent, linear, and non-commutative varieties-- homotopy, not so much), sequent calculus, lambek calculus
* Firm grasp of formal logic via type theory thanks to computational trinitarianism
* Basic background with category theory, albeit mainly through Haskell, and again, computational trinitarianism
* Competent with functional and object-oriented abstractions and design patterns
* In case you're running a keyword filter: YES I know recursion, loops, iteration, collections, maps (dictionaries), filtering, objects, classes, subtyping polymorphism, inheritance, interfaces, abstract classes, generics, lists, arrays, pointers, sets, multisets, stacks, trees, graphs, optionals, options, tuples, eithers, zippers, continuations (somewhat), strings, characters, integers (byte, ubyte, short, ushort, int, uint, long, ulong, bignum), decimals (float, double, bigdecimal), fixed-points, inductive types, coinductive types, lazy/eager evaluation, booleans, boolean algebra, records, unions, catamorphisms, isomorphisms, functors, monads, monoids, traversables, applicatives, foldables, semigroups, arrows, lenses, continuation-passing style, exceptions, coroutines, green threads, normal threads, mutexes, cooperative multitasking, messages, locks, atomic references, thread pools, reentrancy, thread-local storage, immutability, reference counting, garbage collection, pattern matching, category, vertical types, fixpoints, LUBs, promises, etc
* Understand how CPUs are designed and implemented (I built a 16-bit von-neumann stack-based CPU in Minecraft, and proceeded to design a real-life one on paper, though it has never been implemented)
* Linguistics (including artificial language construction) is another hobby of mine, and you wouldn't believe how often it comes up!
* Formal languages and grammar in terms of production rules
* Object-oriented, (purely) functional, imperative/procedural, reactive

Programming languages:
* Java (I write most of my projects in this, Robotics club), C# (an XNA platformer a couple years back, a Minecraft clone using the Unity game engine-- most of my Java knowledge is transferrable too)
* Haskell (used to write programming languages, parsers, and projects that don't require a lot of state or IO)
* Racket & Chicken Scheme, dialects of Lisp, Untyped Lambda Calculus (I used it often earlier on, including a web server, XHTML/XML/SVG generation DSL, and it sat right in the core of my operating system-- lambda calculus isn't a programming language obviously but it's related-- and I still use Racket Scribble for documentation)
* x86 assembly (used in a couple of essential components of my operating system, and used to make a Forth implementation)
* Forth (used in conjunction with x86 assembly to bootstrap itself, as is Forth tradition, but no real programs once I had it)
* Rust (used to write an HTML/XML parser and my Minecraft server implementation, and will likely be used again in the future)
* (X)HTML(5), CSS, SQL, PHP (used to build a webcomic site for a friend in middle school before the project was cancelled, a basic hierarchical board called "thread", and my own (incomplete) site, though it's not very technologically impressive thanks to its deliberately minimalist design (https://lijero.co))
* Prolog (I wrote a good chunk of an implementation of one, though I never finished, and have not used it for any real projects)
* C (portions of the operating system, the VM for that CPU I designed but never built)
* The yet-unnamed programming language I am building right now! (derived from non-commutative linear logic, w/ influences from Haskell, Rust, Lisp, and Forth)

Former projects
===============

Languages
* HTML, XML, SVG parsers and generators, DSLs
* A dozen lisp and lambda calculus implementations (at least one in every language I've ever used)
* An indirect-threaded Forth implementation in x86 assembly
* Reflection-based implementation of the reactive programming paradigm for Java
* The beginnings of a prolog implementation, never finished

Web
* IRC and HTTP, clients and daemons
* A webcomic site for a friend, until the project was cancelled
* A heirarchical board called "thread"
* My own minimalist website

Low-level
* An operating system based on a programming language interpreter in the kernel (actually partially implemented, including the kernel, filesystem, memory manager, terminal, and the language itself), and tons of other plans for other designs that never were built
* A 16-bit von-neumann stack-based CPU in Minecraft using pure redstone, before the age of comparators, hoppers, and command blocks
* A CPU design for real life on paper, never implemented, and a basic virtual marchine for that CPU

Games
* Tons of games in Scratch from when I was younger, too many to list
* I owned a Minecraft server with 60+ concurrent connections at peak hours for a couple years
   - most of the content was based on custom scripts, most of which I wrote-- most vanilla content was replaced somehow, including map generation, monster spawns, the actual monsters themselves, radiation and thirst mechanics, and the beginnings of a technology mod
   - I learned through trial-and-error (mostly error) how to manage a large community of people effectively
   - this was how I really got into programming
   - used a custom modpack, distributed via a self-hosted technic solder instance
   - this is how I learnt about VPSes, and was my first introduction to Linux
   - included a network of sub-servers (the desert world, the ice world, the normal world, the vanilla desert world, a games server, a sandbox server + quest build server, and a hub) via Bungee-- though this was overkill for the server population so I went back to one server with multiple worlds
* A Minecraft server implementation written in Rust
   - built from reverse-engineered protocol docs (http://wiki.vg/Protocol)
   - never got enough done to be useable for gameplay, but it was a cool project
* A Minecraft clone written in C# with unity. I wrote the
   - infinite map generation with simplex noise that, if I recall correctly, I implemented myself
   - mesh generation and optimization
   - map editing capabilities
   - most of the way to networked multiplayer (partially TCP, partially UDP)
* I've used and written various event systems and can relate them to reactive programming
* Generic simple games like pongs, breakouts, snakes, etc
* I have a pretty solid knowledge of OpenGL, but haven't written anything complex using it directly

Robotics
* A bunch of internal abstractions for our robotics club involving basic functionality like motor controls, input mapping and configuration, and operation modes
* A dataflow abstraction that got sidetracked into a reflection-based implementation of reactive programming for Java and then evolved into another project
* Started work on cube recognition software, but we had a really bad season and dropped out long before it was completed

Current Projects
================

Active
* A programming language derived from dependent ordered linear type theory (and hopefully homotopy theory influences if I ever learn it) based on the construction of valid terms using context-sensitive grammar production rules, with an emphasis on practicality (hey, don't laugh!)
* A rule processing engine + transactional database focused on generating, processing, and querying business data, using modern structure and a powerful rule description language

Planned, eventually
* An operating system based on my programming language and category-theoretic abstractions, rather than the traditional model (I believe this will make things simpler while still being useable, hopefully)
* A distributed overlay network for a secure, autonomous internet, and powerful abstractions for writing internet-based applications and datastores, and decentralized networks
   - the two above concepts are extremely closely intertwined with eachother and the language


Real-life stuff
===============

Clubs:
* Robotics (school club)
* Dungeons & dragons (school club)
* Dungeons & dragons (group of friends)
* Speech & debate (dropped out this year, definitely will do next year)
* Marching band (class, during football season)
* Concert band (class, the rest of the year)
* Jazz band (0-period class before school)

Things I like to do:
* Hiking & backpacking
* Cycling (to a lesser degree)
* Dungeons & dragons
* Perform music
* Listen to all sorts of music
* Play board games or poker (for chips) & chat with friends
* Occasional video games like Dwarf Fortress, Factorio, or Terraria with friends, formerly a LOT LOT of Minecraft

Hobbies:
* Programming language theory
* Type theory & other mathematical stuff
* Linguistics & artificial language construction (conlanging)
* Worldbuilding (formerly, and hopefully again someday)
* Music theory (this one is more far off, in that I don't work with it a lot yet)

In summary...
* I am fascinated by conceptual structure & expression (programming languages, human languages, mathematics, music theory, speech & debate)
* I love creativity in structured contexts (worldbuilding, conlanging, dungeons & dragons, music theory)
* I love music (concert band, marching band, jazz band, music theory)
* I love nature
